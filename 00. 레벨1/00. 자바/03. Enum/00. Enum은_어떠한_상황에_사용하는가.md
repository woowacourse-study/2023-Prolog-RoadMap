# Enum은 어떠한 상황에 사용하는가?

## 🟧 Enum 이란 ?

- JDK 1.5 버전부터 나온 열거형 상수
- 관련이 있는 상수들의 집합

<br>
<br>
<br>

## 🟧 Enum 사용 이유 ?

- 코드 가독성이 좋다.
- 인스턴스 생성과 상속을 방지할 수 있다.
- 구현의 의도를 알기 쉽다.

<br>
<br>
<br>

> 이제부터 상황 예시를 보도록하자.
>
> 목차 :
>
> case 01. 인스턴스 열거
>
> case 02. enum 열거

<br>
<br>
<br>

# 🟢 case 01. 정수 열거 패턴

class의 클래스 상수로 선언하여 기물(Piece)의 상태를 나타낸다.

```java
public class PieceInteger {
    public static final int PAWN = 0;
    public static final int ROOK = 1;
    public static final int BISHOP = 2;
    public static final int KNIGHT = 3;
    public static final int QUEEN = 4;
    public static final int KING = 5;
}
```

<br>
<br>
<br>

현재 `PieceInteger` 에 있는 `Piece`의 상태들에 따라 각각의 움직임 기능을 구현해보자.

## 😂 단점

- 타입 표현을 `Integer`, `String` 등으로 이용하므로 중복될 수 있어 오류가 발생할 수 있다.
- if문이 반복되어 가독성이 떨어진다.

```java
public class Piece {
    public static final int PAWN = 0;
    public static final int ROOK = 1;
    public static final int BISHOP = 2;
    public static final int KNIGHT = 3;
    public static final int QUEEN = 4;
    public static final int KING = 5;

    // if문의 반복으로 가독성이 떨어진다.
    public void move(final int index) {
        if (PAWN == index) {
            System.out.println("PAWN은 [NORTH || SOUTH || NORTH_NORTH || ...]로 움직인다.");
        }
        if (ROOK == index) {
            System.out.println("ROOK은 [NORTH || WEST || EAST || SOUTH]로 움직인다.");
        }
        if (BISHOP == index) {
            System.out.println("BISHOP은 [NORTH_WEST || NORTH_EAST || SOUTH_WEST || SOUTH_EAST]로 움직인다.");
        }
        if (KNIGHT == index) {
            System.out.println("KNIGHT는 [NORTH_NORTH_WEST || NORTH_NORTH_EAST || ...]로 움직인다.");
        }
        if (QUEEN == index) {
            System.out.println("QUEEN은 [NORTH || WEST || EAST || SOUTH || NORTH_WEST || ...]로 움직인다.");
        }
        if (KING == index) {
            System.out.println("KING은 [NORTH || WEST || EAST || SOUTH || NORTH_WEST || ...]로 움직인다.");
        }
    }
}
```

```java
public class Main {
    public static void main(String[] args) {

        Piece piece = new Piece();

        piece.move(Piece.PAWN);   // PAWN(0)=
        piece.move(Piece.ROOK);   // ROOK(1)
        piece.move(Piece.BISHOP); // BISHOP(2)
        piece.move(Piece.KNIGHT); // KNIGHT(3)
        piece.move(Piece.QUEEN);  // QUEEN(4)
        piece.move(Piece.KING);   // KING(5)
    }
}
```

<br>
<br>
<br>

# 🟢 case 02. enum 열거


즉, `case01`은 상태와 연관된 행위가 여러 곳에 퍼져있어 한 눈에 파악하기 어렵다.

하지만 enum을 활용하면 매우 간단하게 표현할 수 있다.

<br>
<br>
<br>

## 😄 01. 열거가 필요한 경우

- 타입을 enum 자료형으로 이용한다.
    - `0, 1, 2, ...` 으로 타입을 분리할 때 보다 확실하다.
    - 싱글톤을 보장하므로 `==` 비교가 가능하다.
    - `toString()` 메서드를 이용하면 바로 enum 자료형의 이름을 가져올 수 있다.

```java
public enum Piece {
    PAWN,
    ROOK,
    BISHOP,
    KNIGHT,
    QUEEN,
    KING;
}
```

<br>
<br>
<br>

## 😄 02. enum 자료형에 메서드나 필드를 추가할 수 있다.

- 가독성이 좋다.
- 상태와 행위를 한 눈에 볼 수 있다.
- 라인수가 적다. `[약 30 라인]`
- if문이 필요 없다.

```java
public enum Piece {
    PAWN(() -> System.out.println("PAWN은 [NORTH || SOUTH || NORTH_NORTH || ...]로 움직인다.")),
    ROOK(() -> System.out.println("ROOK은 [NORTH || WEST || EAST || SOUTH]로 움직인다.")),
    BISHOP(() -> System.out.println("BISHOP은 [NORTH_WEST || NORTH_EAST || SOUTH_WEST || SOUTH_EAST]로 움직인다.")),
    KNIGHT(() -> System.out.println("KNIGHT는 [NORTH_NORTH_WEST || NORTH_NORTH_EAST || ...]로 움직인다.")),
    QUEEN(() -> System.out.println("QUEEN은 [NORTH || WEST || EAST || SOUTH || NORTH_WEST || ...]로 움직인다.")),
    KING(() -> System.out.println("KING은 [NORTH || WEST || EAST || SOUTH || NORTH_WEST || ...]로 움직인다."));

    private final Move movement;

    Piece(final Move movement) {
        this.movement = movement;
    }

    public void move() {
        this.movement.move();
    }
}

@FunctionalInterface
interface Move {
    void move();
}
```

```java
public class Main {
    public static void main(String[] args) {

        Piece.PAWN.move();
        Piece.ROOK.move();
        Piece.BISHOP.move();
        Piece.KNIGHT.move();
        Piece.QUEEN.move();
        Piece.KING.move();
    }
}
```

<br>
<br>
<br>

# 🟧 정리하자면

- enum 좋은 경우
    - 상태와 행위를 같이 관리할 경우
    - 타입을 정의해야할 경우
    - enum을 이용하면 편리하다.

- enum 나쁜 경우
    - enum에 몰아넣으면 오히려 복잡해질 수 있다.
    - enum은 Integer, String에 비해 더 많은 메모리를 런타임에 사용한다.
    - 때문에 enum을 남발하지는 말자.
